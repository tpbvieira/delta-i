 - Listagem os eventos que podem ser monitorados pelo VTune para identificar chamadas SIMD(http://software.intel.com/en-us/articles/identifying-jvm-vectorization-simd-usage-with-the-vtunetm-performance-analyzer/)
 - No Windows o default é client version, no Linux o default é server. No client, o startup das aplicações é otimizado, no modo server a otimização é para execução das aplicações.
 - The Java HotSpot VM is designed to be insensitive to race conditions caused by preemption and/or multiprocessing while executing Java programming language code, the Java programming language threads will automatically take advantage of whatever scheduling and processor allocation policies the native OS provides.
 - Não usa mais dois niveis de indireção para representar referência a objetos, utilizando agora apenas um, semelhante ao feito pelas aplicacoes C.
 - Otimizações:
	- Deep inlining and inlining of potentially virtual calls: as described above, method inlining combined with global analysis and dynamic deoptimization are used by both the client and server compilers to enable deep inlining and therefore elimination of a substantial amount of method call overhead.
	- Fast instanceof/checkcast: the Java HotSpot VM and compilers support a novel technique for accelerating the dynamic type tests frequently required by the Java programming language for type safety. This further decreases the run-time cost of programming in object-oriented style.
	- Range check elimination: The Java programming language specification requires array bounds checking to be performed with each array access. An index bounds check can be eliminated when the compiler can prove that an index used for an array access is within bounds.
	- Loop unrolling: the Server VM features loop unrolling, a standard compiler optimization that enables faster loop execution. Loop unrolling increases the loop body size while simultaneously decreasing the number of iterations. Loop unrolling also increases the effectiveness of other optimizations.
	- Feedback-directed optimizations: the Server VM performs extensive profiling of the program in the interpreter before compiling the Java bytecode to optimized machine code. This profiling data provides even more information to the compiler about data types in use, hot paths through the code, and other properties. The compiler uses this information to more aggressively and optimistically optimize the code in certain situations. If one of the assumed properties of the code is violated at run time, the code is deoptimized and later recompiled and reoptimized.

 - Client Optimization = In the first phase, a platform-independent front end constructs a high-level intermediate representation (HIR) from the bytecodes. The HIR uses static single assignment (SSA) form to represent values in order to more easily enable certain optimizations, which are performed during and after IR construction. In the second phase, the platform-specific back end generates a low-level intermediate representation (LIR) from the HIR. The final phase performs register allocation on the LIR using a customized version of the linear scan algorithm, does peephole optimization on the LIR and generates machine code from it.
 - Server Optimization = It uses an advanced static single assignment (SSA)-based IR for optimizations. The optimizer performs all the classic optimizations, including dead code elimination, loop invariant hoisting, common subexpression elimination, constant propagation, global value numbering, and global code motion. It also features optimizations more specific to Java technology, such as null-check and range-check elimination and optimization of exception throwing paths. The register allocator is a global graph coloring allocator and makes full use of large register sets that are commonly found in RISC microprocessors.
